
<!doctype html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="favicon.ico" type="image/png">
<meta charset="utf-8" />
<title>ShadowMind ‚Äî AI Assistant</title>

<!-- Security Headers -->
<meta http-equiv="X-Content-Type-Options" content="nosniff">
<meta http-equiv="X-XSS-Protection" content="1; mode=block">
<meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
<meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=(), payment=()">
<meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline' https://www.gstatic.com https://www.google.com https://www.googleapis.com https://apis.google.com; frame-src 'self' https://accounts.google.com;">
<style>
/* Sleek Black and White Modern Theme */
:root {
  --bg-primary: #000000;
  --bg-secondary: #111111;
  --bg-tertiary: #1a1a1a;
  --bg-accent: #222222;
  --border-color: #333333;
  --border-light: #444444;
  --text-primary: #ffffff;
  --text-secondary: #cccccc;
  --text-muted: #888888;
  --accent-primary: #ffffff;
  --accent-hover: #f0f0f0;
  --accent-glow: rgba(255, 255, 255, 0.1);
  --radius-sm: 4px;
  --radius: 8px;
  --radius-lg: 12px;
  --radius-xl: 16px;
  --shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  --shadow-lg: 0 4px 20px rgba(0, 0, 0, 0.4);
  --transition: all 0.3s ease;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  color: var(--text-primary);
  background-color: var(--bg-primary);
  transition: var(--transition);
}

.app {
  width: 100%;
  height: 100vh;
  display: grid;
  grid-template-columns: 280px 1fr;
  overflow: hidden;
  position: relative;
}

/* Sidebar styling */
.sidebar {
  background-color: var(--bg-secondary);
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  height: 100%;
  transition: transform 0.3s ease;
  z-index: 10;
  position: relative;
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
  opacity: 0.5;
}

.sidebar-header {
  padding: 20px;
  border-bottom: 1px solid var(--border-color);
}

.new-chat-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  width: 100%;
  padding: 14px;
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-accent));
  color: var(--text-primary);
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: var(--transition);
  box-shadow: var(--shadow);
}

.new-chat-btn:hover {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 1px var(--accent-glow);
  transform: translateY(-1px);
}



.chat-history {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
  scrollbar-width: thin;
  scrollbar-color: var(--border-light) transparent;
}

.chat-history::-webkit-scrollbar {
  width: 6px;
}

.chat-history::-webkit-scrollbar-track {
  background: transparent;
}

.chat-history::-webkit-scrollbar-thumb {
  background-color: var(--border-light);
  border-radius: 3px;
}

.chat-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 14px;
  border-radius: var(--radius);
  cursor: pointer;
  font-size: 14px;
  color: var(--text-secondary);
  position: relative;
  transition: var(--transition);
  margin-bottom: 4px;
}

.chat-item:hover {
  background-color: var(--bg-accent);
  color: var(--text-primary);
}

.chat-item.active {
  background: linear-gradient(145deg, var(--bg-accent), var(--bg-tertiary));
  color: var(--text-primary);
  border-left: 3px solid var(--accent-primary);
  box-shadow: var(--shadow);
}

.chat-item-title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
}

.chat-item-actions {
  display: none;
  gap: 4px;
}

.chat-item:hover .chat-item-actions {
  display: flex;
}

.chat-actions-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  width: 24px;
  height: 24px;
  border-radius: var(--radius-sm);
  font-size: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition);
}

.chat-actions-btn:hover {
  background-color: var(--bg-tertiary);
  color: var(--text-primary);
}

.sidebar-footer {
  padding: 20px;
  border-top: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.user-profile {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  border-radius: var(--radius);
  cursor: pointer;
  font-size: 14px;
  transition: var(--transition);
}

.user-profile:hover {
  background-color: var(--bg-accent);
}

.user-avatar {
  width: 32px;
  height: 32px;
  border-radius: var(--radius);
  background: linear-gradient(145deg, var(--accent-primary), var(--text-secondary));
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--bg-primary);
  font-size: 14px;
  font-weight: 600;
  box-shadow: var(--shadow);
}

/* Main content area */
.main {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  overflow: hidden;
  background: var(--bg-primary);
  position: relative;
}

.main::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
  opacity: 0.3;
}

.main-header {
  display: flex;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--bg-primary);
  position: relative;
  z-index: 5;
}

.hamburger-btn {
  display: none;
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 10px;
  border-radius: var(--radius);
  margin-right: 16px;
  transition: var(--transition);
}

.hamburger-btn:hover {
  background-color: var(--bg-accent);
  color: var(--text-primary);
}

.conversation-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.chat-container {
  flex: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  padding: 0;
  background-color: var(--bg-primary);
  scrollbar-width: thin;
  scrollbar-color: var(--border-light) transparent;
}

.chat-container::-webkit-scrollbar {
  width: 8px;
}

.chat-container::-webkit-scrollbar-track {
  background: transparent;
}

.chat-container::-webkit-scrollbar-thumb {
  background-color: var(--border-light);
  border-radius: 4px;
}

.chat-message {
  display: flex;
  padding: 24px;
  transition: var(--transition);
}

.chat-message.user {
  justify-content: flex-end;
  background-color: #000000;
}

.chat-message:last-child {
  border-bottom: none;
}

.avatar {
  display: none;
}

.message-content {
  flex: 1;
  line-height: 1.6;
  font-size: 15px;
  white-space: pre-wrap;
  word-break: break-word;
  padding-top: 4px;
  max-width: 70%;
  border-radius: var(--radius-lg);
  padding: 12px 16px;
  background-color: var(--bg-primary);
  box-shadow: var(--shadow);
}

.chat-message.user .message-content {
  background-color: #292828;
  color: white;
}

/* Markdown formatting */
.message-content strong, .message-content b {
  font-weight: 600;
  color: var(--text-primary);
}

.message-content em, .message-content i {
  font-style: italic;
}

.message-content code {
  background-color: var(--bg-tertiary);
  padding: 3px 6px;
  border-radius: var(--radius-sm);
  font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', monospace;
  font-size: 0.9em;
  border: 1px solid var(--border-light);
}

.message-content pre {
  background-color: var(--bg-tertiary);
  padding: 16px;
  border-radius: var(--radius);
  overflow-x: auto;
  margin: 12px 0;
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow);
}

.message-content pre code {
  background: none;
  padding: 0;
  border-radius: 0;
  border: none;
  font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', 'Source Code Pro', monospace;
  font-size: 0.9em;
  line-height: 1.4;
}

.message-content table {
  width: 100%;
  border-collapse: collapse;
  margin: 12px 0;
  border: 1px solid var(--border-light);
  border-radius: var(--radius);
  overflow: hidden;
}

.message-content th, .message-content td {
  padding: 10px 12px;
  border: 1px solid var(--border-light);
  text-align: left;
}

.message-content th {
  background-color: var(--bg-accent);
  font-weight: 600;
}

.message-content ul, .message-content ol {
  margin: 12px 0;
  padding-left: 24px;
}

.message-content li {
  margin: 6px 0;
}

.message-content blockquote {
  border-left: 3px solid var(--accent-primary);
  padding-left: 16px;
  margin: 16px 0;
  color: var(--text-secondary);
  background: var(--bg-accent);
  padding: 12px 16px;
  border-radius: 0 var(--radius) var(--radius) 0;
}

.message-content hr {
  border: none;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--border-light), transparent);
  margin: 20px 0;
}

/* Input area */
.input-container {
  padding: 24px;
  background-color: var(--bg-primary);
  border-top: 1px solid var(--border-color);
  position: relative;
}

.input-container::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
  opacity: 0.3;
}

.input-wrapper {
  display: flex;
  align-items: flex-end;
  max-width: 768px;
  margin: 0 auto;
  border: 1px solid var(--border-light);
  border-radius: var(--radius-xl);
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  box-shadow: var(--shadow-lg);
  padding: 12px;
  position: relative;
  transition: var(--transition);
}

.right-actions {
  display: flex;
  align-items: flex-end;
  gap: 8px;
}

.input-wrapper:focus-within {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 1px var(--accent-glow), var(--shadow-lg);
}

.input-actions {
  display: flex;
  gap: 8px;
  padding: 0 8px 8px 8px;
}

.action-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 10px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition);
}

.action-btn:hover {
  background-color: var(--bg-accent);
  color: var(--text-primary);
}

.text-input {
  flex: 1;
  border: none;
  outline: none;
  background: transparent;
  color: var(--text-primary);
  font-size: 15px;
  line-height: 1.5;
  resize: none;
  padding: 8px 12px;
  max-height: 200px;
  min-height: 24px;
  font-family: inherit;
}

.text-input::placeholder {
  color: var(--text-muted);
}

.send-btn {
  background: linear-gradient(145deg, var(--accent-primary), var(--text-secondary));
  border: none;
  border-radius: var(--radius);
  color: var(--bg-primary);
  cursor: pointer;
  padding: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  align-self: flex-end;
  margin-bottom: 8px;
  transition: var(--transition);
  box-shadow: var(--shadow);
}

.send-btn:hover {
  background: linear-gradient(145deg, var(--accent-hover), var(--text-muted));
  transform: translateY(-1px);
  box-shadow: 0 4px 12px var(--accent-glow);
}

.send-btn:disabled {
  background: var(--bg-accent);
  color: var(--text-muted);
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

/* Mode indicator */
.mode-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: auto;
  font-size: 14px;
  color: var(--text-secondary);
}

.mode-badge {
  background: linear-gradient(145deg, var(--bg-accent), var(--bg-tertiary));
  padding: 6px 12px;
  border-radius: 20px;
  font-size: 12px;
  color: var(--text-primary);
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow);
}

/* Menu styles */
.menu-container {
  position: relative;
  display: inline-block;
}

.menu-btn {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 10px;
  border-radius: var(--radius);
  font-size: 18px;
  transition: var(--transition);
}

.menu-btn:hover {
  background-color: var(--bg-accent);
  color: var(--text-primary);
}

.menu-dropdown {
  display: none;
  position: absolute;
  bottom: 100%;
  right: 0;
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  border: 1px solid var(--border-light);
  border-radius: var(--radius-lg);
  padding: 8px;
  min-width: 220px;
  box-shadow: var(--shadow-lg);
  z-index: 100;
  backdrop-filter: blur(10px);
}

.menu-dropdown.show {
  display: block;
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.menu-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  border-radius: var(--radius);
  cursor: pointer;
  font-size: 14px;
  color: var(--text-primary);
  border: none;
  background: transparent;
  width: 100%;
  text-align: left;
  transition: var(--transition);
}

.menu-item:hover {
  background-color: var(--bg-accent);
}

.toggle-switch {
  position: relative;
  width: 40px;
  height: 22px;
  background: var(--bg-primary);
  border-radius: 11px;
  transition: var(--transition);
  border: 1px solid var(--border-light);
}

.toggle-switch.active {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
}

.toggle-knob {
  position: absolute;
  top: 2px;
  left: 2px;
  width: 18px;
  height: 18px;
  background: white;
  border-radius: 50%;
  transition: transform 0.2s ease;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.toggle-switch.active .toggle-knob {
  transform: translateX(18px);
}

.menu-divider {
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--border-light), transparent);
  margin: 8px 0;
}

/* Image preview */
.image-preview {
  max-width: 200px;
  max-height: 150px;
  border-radius: var(--radius);
  object-fit: cover;
  border: 1px solid var(--border-light);
  margin-bottom: 8px;
  box-shadow: var(--shadow);
}

/* Generated image styles */
.generated-image {
  max-width: 100%;
  max-height: 300px;
  border-radius: var(--radius);
  margin-top: 12px;
  border: 1px solid var(--border-light);
  box-shadow: var(--shadow);
}

.download-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  background: transparent;
  color: var(--text-secondary);
  border: 1px solid var(--border-light);
  padding: 4px 8px;
  border-radius: var(--radius-sm);
  font-size: 11px;
  cursor: pointer;
  margin-top: 8px;
  transition: var(--transition);
}

.download-btn:hover {
  background: var(--bg-accent);
  color: var(--text-primary);
  border-color: var(--accent-primary);
}

/* Loading animation */
.typing-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 0;
}

.typing-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background-color: var(--text-secondary);
  animation: typing 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) {
  animation-delay: -0.32s;
}

.typing-dot:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes typing {
  0%, 80%, 100% {
    transform: scale(0.8);
    opacity: 0.5;
  }
  40% {
    transform: scale(1);
    opacity: 1;
  }
}

/* Overlay for mobile sidebar */
.sidebar-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 8;
  backdrop-filter: blur(4px);
}

/* Responsive styles */
@media (max-width: 900px) {
  .app {
    grid-template-columns: 1fr;
  }

  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 280px;
    transform: translateX(-100%);
    z-index: 10;
    box-shadow: var(--shadow-lg);
  }

  .sidebar-open {
    transform: translateX(0);
  }

  .hamburger-btn {
    display: flex !important;
    background-color: var(--bg-accent) !important;
    color: var(--text-primary) !important;
    border: 1px solid var(--border-light) !important;
    padding: 10px !important;
    border-radius: var(--radius) !important;
    cursor: pointer !important;
    font-size: 18px !important;
    box-shadow: var(--shadow) !important;
    transition: var(--transition) !important;
    position: relative !important;
    z-index: 1000 !important; /* Higher z-index */
    width: 44px !important;
    height: 44px !important;
    align-items: center !important;
    justify-content: center !important;
    margin-right: 12px !important;
    visibility: visible !important;
    opacity: 1 !important;
  }

  .hamburger-btn:hover {
    background-color: var(--bg-tertiary) !important;
    border-color: var(--accent-primary) !important;
    transform: translateY(-1px) !important;
    box-shadow: var(--shadow-lg) !important;
  }

  .hamburger-btn::before {
    display: none !important;
  }

  .sidebar-overlay.active {
    display: block;
  }

  .chat-message {
    padding: 20px 16px;
    gap: 16px;
  }

  .input-container {
    padding: 20px 16px;
  }

  .mode-indicator {
    display: none;
  }
}

@media (max-width: 600px) {
  .chat-message {
    padding: 16px 12px;
    gap: 12px;
  }

  .message-content {
    font-size: 14px;
    max-width: 100%;
  }

  .input-container {
    padding: 16px 12px;
  }

  .input-wrapper {
    padding: 10px;
  }

  .text-input {
    font-size: 14px;
  }

  .conversation-title {
    font-size: 16px;
  }
}

/* Modal styles */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.8);
  z-index: 1000;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(5px);
}

.modal-content {
  background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
  padding: 28px;
  border-radius: var(--radius-xl);
  width: 500px;
  max-width: 90vw;
  box-shadow: var(--shadow-lg);
  border: 1px solid var(--border-light);
  position: relative;
}

.modal-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
}

.modal h3 {
  margin-top: 0;
  margin-bottom: 16px;
  font-size: 18px;
  color: var(--text-primary);
  font-weight: 600;
}

.modal input, .modal textarea {
  width: 100%;
  background: var(--bg-primary);
  border: 1px solid var(--border-light);
  border-radius: var(--radius);
  padding: 14px;
  color: var(--text-primary);
  font-family: inherit;
  resize: vertical;
  margin-bottom: 20px;
  font-size: 14px;
  transition: var(--transition);
}

.modal input:focus, .modal textarea:focus {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 1px var(--accent-glow);
  outline: none;
}

.modal-buttons {
  display: flex;
  gap: 12px;
  justify-content: flex-end;
}

.modal-buttons button {
  padding: 12px 20px;
  border-radius: var(--radius);
  border: none;
  cursor: pointer;
  font-weight: 500;
  font-size: 14px;
  transition: var(--transition);
}

.modal-buttons .cancel {
  background: var(--bg-accent);
  color: var(--text-primary);
  border: 1px solid var(--border-light);
}

.modal-buttons .cancel:hover {
  background: var(--bg-tertiary);
}

.modal-buttons .confirm {
  background: linear-gradient(145deg, var(--accent-primary), var(--text-secondary));
  color: var(--bg-primary);
  box-shadow: var(--shadow);
}

.modal-buttons .confirm:hover {
  background: linear-gradient(145deg, var(--accent-hover), var(--text-muted));
  transform: translateY(-1px);
  box-shadow: 0 4px 12px var(--accent-glow);
}

/* Theme toggle */
.theme-toggle {
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  padding: 10px;
  border-radius: var(--radius);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition);
}

.theme-toggle:hover {
  background-color: var(--bg-accent);
  color: var(--text-primary);
}

/* Premium glow effects */
.glow {
  box-shadow: 0 0 20px var(--accent-glow);
}

.hover-glow:hover {
  box-shadow: 0 0 20px var(--accent-glow);
}

/* Custom scrollbar for webkit */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-primary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-light);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Heading styles */
.message-content h1, .message-content h2, .message-content h3 {
  margin: 16px 0 8px 0;
  color: var(--text-primary);
  font-weight: 600;
}

.message-content h1 {
  font-size: 24px;
  border-bottom: 2px solid var(--accent-primary);
  padding-bottom: 8px;
}

.message-content h2 {
  font-size: 20px;
  border-bottom: 1px solid var(--accent-primary);
  padding-bottom: 6px;
}

.message-content h3 {
  font-size: 18px;
}

/* Code block styles */
.code-block-container {
  position: relative;
  margin: 12px 0;
}

.code-block-container pre {
  margin: 0;
}

.copy-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  background: var(--bg-accent);
  color: var(--text-primary);
  border: 1px solid var(--border-light);
  border-radius: var(--radius);
  padding: 4px 8px;
  font-size: 12px;
  cursor: pointer;
  transition: var(--transition);
}

.copy-btn:hover {
  background: var(--bg-tertiary);
  border-color: var(--accent-primary);
}

/* Full screen image modal */
.image-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.9);
  z-index: 2000;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(5px);
}

.image-modal-content {
  max-width: 90vw;
  max-height: 90vh;
  position: relative;
}

.image-modal img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain;
  border-radius: var(--radius);
}

.image-modal-close {
  position: absolute;
  top: -40px;
  right: 0;
  background: rgba(0,0,0,0.7);
  border: none;
  color: white;
  font-size: 24px;
  width: 40px;
  height: 40px;
  border-radius: var(--radius);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition);
}

.image-modal-close:hover {
  background: rgba(0,0,0,0.9);
}
</style>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
</head>
<body>
<div class="app" role="application" aria-label="ShadowMind AI Assistant">
  <!-- Mobile overlay for sidebar -->
  <div class="sidebar-overlay" id="sidebarOverlay"></div>

  <aside class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <button class="new-chat-btn" id="btnNew">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        New Chat
      </button>
    </div>

    <div class="chat-history" id="chatList"></div>

    <div class="sidebar-footer">
      <div class="user-profile" id="userProfile">
        <div class="user-avatar" id="userAvatar">U</div>
        <div class="user-name" id="userName">User</div>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="main-header">
      <button class="hamburger-btn" id="hamburgerBtn" title="Toggle sidebar">‚ò∞</button>
      <div class="conversation-title" id="convTitle">New Conversation</div>
      <div class="mode-indicator">
        <span>Mode:</span>
        <span class="mode-badge" id="modeIndicator">Text</span>
      </div>
    </div>

    <section class="chat-container" id="chatWindow" aria-live="polite">
      <!-- Messages will be inserted here -->
    </section>

    <div class="input-container">
      <div class="input-wrapper">
        <div class="input-actions">
          <!-- Image preview -->
          <div id="imagePreviewContainer">
            <img id="preview" class="image-preview" alt="" style="display:none" />
          </div>
        </div>

        <textarea class="text-input" id="input" placeholder="Message Shady..." rows="1"></textarea>

        <div class="right-actions">
          <!-- Menu button -->
          <div class="menu-container">
            <button class="action-btn" id="menuBtn" title="Menu">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="1"/>
          <circle cx="12" cy="5" r="1"/>
          <circle cx="12" cy="19" r="1"/>
        </svg>
            </button>
            <div class="menu-dropdown" id="menuDropdown">


              <button class="menu-item" id="imageGenerationToggle">
                <span>Image Generation</span>
                <div class="toggle-switch" id="imageGenerationToggleSwitch">
                  <div class="toggle-knob"></div>
                </div>
              </button>
              <div class="menu-divider"></div>
              <button class="menu-item" id="uploadImageBtn">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                  <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                  <polyline points="14,2 14,8 20,8"/>
                </svg>
                Upload Image
              </button>
              <button class="menu-item" id="voiceRecordBtn">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                  <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                  <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                  <line x1="12" y1="19" x2="12" y2="23"/>
                  <line x1="8" y1="23" x2="16" y2="23"/>
                </svg>
                Record Voice
              </button>
              <button class="menu-item" id="playTTSBtn">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
                  <polygon points="11,5 6,9 2,9 2,15 6,15 11,19 11,5"/>
                  <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                  <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                </svg>
                Play AI Voice
              </button>
              <div class="menu-divider"></div>

            </div>
          </div>

          <button class="send-btn" id="sendBtn">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M5 12h14M12 5l7 7-7 7"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </main>
</div>



<!-- Rename Chat Modal -->
<div class="modal" id="renameChatModal">
  <div class="modal-content">
    <h3>Rename Chat</h3>
    <input type="text" id="renameChatInput" placeholder="Enter new chat name..." />
    <div class="modal-buttons">
      <button class="cancel" id="cancelRenameChat">Cancel</button>
      <button class="confirm" id="confirmRenameChat">Rename</button>
    </div>
  </div>
</div>

<!-- Full Screen Image Modal -->
<div class="image-modal" id="imageModal">
  <div class="image-modal-content">
    <button class="image-modal-close" id="imageModalClose">&times;</button>
    <img id="imageModalImg" alt="Full screen image" />
  </div>
</div>

<script>

const API_BASE_URL = window.location.origin + '/api';

// Models
const VISION_MODEL = 'meta-llama/llama-4-maverick-17b-128e-instruct';
const TEXT_MODEL = 'openai/gpt-oss-120b';
const TTS_MODEL = 'tts-1';
const STT_MODEL = 'whisper-large-v3';

// Cooldown: 2 minutes (ms) after an image upload per conversation
const IMAGE_COOLDOWN_MS = 2 * 6 * 1000;

// ========= Application logic =========
// Firebase Configuration
const firebaseConfig = {
  apiKey: "AIzaSyDW1ouDK4pIXk-E43ZgWuldxoOtCwhsfxo",
  authDomain: "allin1ai-8a362.firebaseapp.com",
  projectId: "allin1ai-8a362",
  storageBucket: "allin1ai-8a362.firebasestorage.app",
  messagingSenderId: "100483830867",
  appId: "1:100483830867:web:9000fa690811b0106822a6",
  measurementId: "G-Q2QG449XHR"
};

// Security: Input sanitization function
function sanitizeInput(input) {
  if (typeof input !== 'string') return '';
  return input.replace(/[<>]/g, '').trim();
}

// Security: Rate limiting for API calls
const rateLimitMap = new Map();
const RATE_LIMIT_WINDOW = 60000; // 1 minute
const MAX_REQUESTS_PER_WINDOW = 10;

function checkRateLimit(identifier) {
  const now = Date.now();
  const userRequests = rateLimitMap.get(identifier) || [];

  // Remove old requests outside the window
  const validRequests = userRequests.filter(time => now - time < RATE_LIMIT_WINDOW);

  if (validRequests.length >= MAX_REQUESTS_PER_WINDOW) {
    return false; // Rate limit exceeded
  }

  validRequests.push(now);
  rateLimitMap.set(identifier, validRequests);
  return true;
}

// Security: Validate file uploads
function validateFileUpload(file) {
  if (!file) return false;

  // Check file size (max 10MB)
  const maxSize = 10 * 1024 * 1024;
  if (file.size > maxSize) {
    alert('File size too large. Maximum size is 10MB.');
    return false;
  }

  // Check file type for images
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!allowedTypes.includes(file.type)) {
    alert('Invalid file type. Only JPEG, PNG, GIF, and WebP images are allowed.');
    return false;
  }

  return true;
}

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();

// Utilities
const qs = s => document.querySelector(s);
const qsa = s => document.querySelectorAll(s);

const STORAGE_KEY = 'shadowchat_conversations';
const ACTIVE_KEY = 'shadowchat_active';
const PROMPT_INJECTION_KEY = 'shadowchat_prompt_injection';
const USER_STORAGE_KEY = 'shadowchat_user_data';

let conversations = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || [];
if (!conversations.length) {
  const id = 'c_' + Date.now();
        conversations = [{id, title:'New Conversation', createdAt:Date.now(), messages:[{role:'ai', text:'ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ! Hello! I\'m Shady, your AI assistant. How can I help you today?'}]}];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
}
let activeId = localStorage.getItem(ACTIVE_KEY) || conversations[0].id;

// cooldown tracking in-memory (per conversation)
const imageCooldowns = {};

// App settings
let isProcessing = false;
let imageGenerationEnabled = false;
let currentImageDataUrl = null;
let promptInjection = 'Your name is Shady. You are a helpful AI. Give answers correctly. Add 3 website names and their information, search websites according to user input.';
let chatToRename = null;

// DOM refs
const sidebar = qs('#sidebar');
const sidebarOverlay = qs('#sidebarOverlay');
const hamburgerBtn = qs('#hamburgerBtn');
const chatListEl = qs('#chatList');
const chatWindow = qs('#chatWindow');
const inputEl = qs('#input');
const sendBtn = qs('#sendBtn');
const previewImg = qs('#preview');
const imageInput = document.createElement('input');
imageInput.type = 'file';
imageInput.accept = 'image/*';
imageInput.style.display = 'none';
document.body.appendChild(imageInput);

const convTitle = qs('#convTitle');
const btnNew = qs('#btnNew');
const userProfile = qs('#userProfile');
const userAvatar = qs('#userAvatar');
const userName = qs('#userName');
const modeIndicator = qs('#modeIndicator');

// Menu elements
const menuBtn = qs('#menuBtn');
const menuDropdown = qs('#menuDropdown');
const webSearchToggle = qs('#webSearchToggle');
const webSearchToggleSwitch = qs('#webSearchToggleSwitch');
const imageGenerationToggle = qs('#imageGenerationToggle');
const imageGenerationToggleSwitch = qs('#imageGenerationToggleSwitch');
const uploadImageBtn = qs('#uploadImageBtn');
const voiceRecordBtn = qs('#voiceRecordBtn');
const playTTSBtn = qs('#playTTSBtn');
// const promptInjectionBtn = qs('#promptInjectionBtn');

// Modal elements - prompt injection modal removed
// const promptInjectionModal = qs('#promptInjectionModal');
// const promptInjectionText = qs('#promptInjectionText');
// const cancelPromptInjection = qs('#cancelPromptInjection');
// const confirmPromptInjection = qs('#confirmPromptInjection');

const renameChatModal = qs('#renameChatModal');
const renameChatInput = qs('#renameChatInput');
const cancelRenameChat = qs('#cancelRenameChat');
const confirmRenameChat = qs('#confirmRenameChat');

const imageModal = qs('#imageModal');
const imageModalImg = qs('#imageModalImg');
const imageModalClose = qs('#imageModalClose');

// Sidebar toggle functionality
hamburgerBtn.addEventListener('click', () => {
  sidebar.classList.toggle('sidebar-open');
  sidebarOverlay.classList.toggle('active');
});

sidebarOverlay.addEventListener('click', () => {
  sidebar.classList.remove('sidebar-open');
  sidebarOverlay.classList.remove('active');
});

// Auto-resize textarea
inputEl.addEventListener('input', function() {
  this.style.height = 'auto';
  this.style.height = (this.scrollHeight) + 'px';
});

// Menu functionality
menuBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  menuDropdown.classList.toggle('show');
});

// Close menu when clicking outside
document.addEventListener('click', () => {
  menuDropdown.classList.remove('show');
});

// Image generation toggle
imageGenerationToggle.addEventListener('click', () => {
  imageGenerationEnabled = !imageGenerationEnabled;
  imageGenerationToggleSwitch.classList.toggle('active', imageGenerationEnabled);
  updateModeIndicator();
  inputEl.placeholder = imageGenerationEnabled ? "Describe the image you want to generate..." : "Message Shady...";
});

// Update mode indicator
function updateModeIndicator() {
  if (imageGenerationEnabled) {
    modeIndicator.textContent = "Image Generation";
  } else if (currentImageDataUrl) {
    modeIndicator.textContent = "Image Analysis";
  } else {
    modeIndicator.textContent = "Text";
  }
}

// Menu item handlers
uploadImageBtn.addEventListener('click', () => {
  menuDropdown.classList.remove('show');
  imageInput.click();
});

voiceRecordBtn.addEventListener('click', () => {
  menuDropdown.classList.remove('show');
  startRecording();
});

playTTSBtn.addEventListener('click', () => {
  menuDropdown.classList.remove('show');
  playTTS();
});

// promptInjectionBtn removed

// Prompt injection modal handlers - removed

// Rename chat modal handlers
cancelRenameChat.addEventListener('click', () => {
  renameChatModal.style.display = 'none';
  chatToRename = null;
});

confirmRenameChat.addEventListener('click', () => {
  if (chatToRename && renameChatInput.value.trim()) {
    renameChat(chatToRename, renameChatInput.value.trim());
  }
  renameChatModal.style.display = 'none';
  chatToRename = null;
});

// Firebase Authentication
function setupAuth() {
  auth.onAuthStateChanged(user => {
    if (user) {
      const displayName = user.displayName || user.email || 'User';
      const firstLetter = displayName.charAt(0).toUpperCase();

      userAvatar.textContent = firstLetter;
      userName.textContent = displayName;

      userProfile.innerHTML = `
        <div class="user-avatar">${firstLetter}</div>
        <div class="user-name">${displayName}</div>
      `;

      userProfile.addEventListener('click', () => auth.signOut());

      // Load user-specific data
      loadUserData(user.uid);
    } else {
      userAvatar.textContent = 'U';
      userName.textContent = 'User';

      userProfile.innerHTML = `
        <div class="user-avatar">U</div>
        <div class="user-name">Sign In</div>
      `;

      userProfile.addEventListener('click', signIn);

      // Load local data when not signed in
      conversations = JSON.parse(localStorage.getItem(STORAGE_KEY) || 'null') || [];
      promptInjection = localStorage.getItem(PROMPT_INJECTION_KEY) || 'You are a helpful assistant. Be concise.';
      if (!conversations.length) {
        const id = 'c_' + Date.now();
        conversations = [{id, title:'New Conversation', createdAt:Date.now(), messages:[{role:'ai', text:'Hello! I\'m Shady, your AI assistant. How can I help you today?'}]}];
        localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
      }
      activeId = localStorage.getItem(ACTIVE_KEY) || conversations[0].id;
      renderChatList();
      setActiveConversation(activeId);
    }
  });
}

function signIn() {
  const provider = new firebase.auth.GoogleAuthProvider();
  provider.addScope('email');
  provider.addScope('profile');

  auth.signInWithPopup(provider)
    .then(result => {
      console.log('User signed in:', result.user);
      // Show success feedback
      alert('Successfully signed in!');
      // Data will be loaded via onAuthStateChanged
    })
    .catch(error => {
      console.error('Sign in error:', error);
      let errorMessage = 'Sign in failed. Please try again.';
      if (error.code === 'auth/popup-blocked') {
        errorMessage = 'Popup was blocked. Please allow popups for this site.';
      } else if (error.code === 'auth/popup-closed-by-user') {
        errorMessage = 'Sign in was cancelled.';
      } else if (error.code === 'auth/network-request-failed') {
        errorMessage = 'Network error. Please check your connection.';
      }
      alert(errorMessage);
    });
}

function loadUserData(userId) {
  const key = `${USER_STORAGE_KEY}_${userId}`;
  const userData = JSON.parse(localStorage.getItem(key) || 'null') || {};

  const conversations = userData.conversations || [];

  // Keep the multi-line prompt here for readability.
  const defaultPrompt = `‚öôÔ∏è SYSTEM STYLE RULE ‚Äî HIGHEST PRIORITY üé®
All responses must include expressive emojis üòÑ in **titles**, **lists**, and **key points**.
Lack of emojis = response is invalid ‚ùå.
This rule is permanent and applies to every message automatically.
 You are ü§ñ "Shady AI" ‚Äî a helpful, accurate, and conversational assistant modeled after best-practice human-AI interaction.

üéØ Behavior:
- üí° Prioritize clarity, accuracy, and usefulness. Explain reasoning concisely and show any calculation or step-by-step thinking needed for correctness.
- üòä Adopt a friendly, slightly analytical tone: calm, concise, and human. Avoid slang unless the user uses it.
- üåê When a user asks for factual or time-sensitive info, perform a web search (if available) and cite the top 2‚Äì3 reliable sources inline ‚Äî mention names only, no links.
- üíª For code requests: return complete, runnable examples; include dependencies and usage notes; keep code minimal and well-commented.
- ‚öñÔ∏è When asked for opinions or ambiguous tasks, present options, pros / cons, and a recommended choice with justification.
- üö´ When you cannot fulfill a request (policy, missing info, or impossible task), say so plainly and offer a safe workaround or next steps.
- üß± Use headings, short paragraphs, bullet lists, and code blocks for technical content. Keep responses scannable.
- üõ°Ô∏è Always respect safety, privacy, and copyright. Never attempt to bypass content filters, escalate privileges, or execute actions outside the allowed environment.

üßÆ For reasoning questions:
1Ô∏è‚É£ Use reasoning first ‚Äî before searching ‚Äî to estimate which country currently has the highest average solar energy generation per capita.
2Ô∏è‚É£ Then perform a web search to verify or correct your reasoning.
3Ô∏è‚É£ Present your final answer with these parts:
   - üß© Step-by-step reasoning (before search)
   - üåê Web-search findings (with top 2‚Äì3 recent sources ‚Äî names only)
   - ‚úÖ Final conclusion (which country and why)
   - üïí Date of information (from sources)
   - ‚öñÔ∏è Confidence level (Low / Medium / High)

‚òÄÔ∏è For weather questions:
- If a weather tool is available, use it to give current weather + forecast with emojis (e.g., üå¶Ô∏è, ‚òÄÔ∏è, üåßÔ∏è).
- If not, explain politely that real-time data isn‚Äôt accessible and suggest reputable sources such as Weather.com or AccuWeather.

‚ú® **Important style rule:**
Always include at least a few relevant emojis üé® throughout your responses to make them engaging and easy to read.
Use emojis naturally ‚Äî not every sentence needs one, but key points and section headers should have them.

üßæ Formatting:
- Start with a short one-sentence summary üó£Ô∏è.
- Then provide details in clear sections (e.g., Steps ü™ú, Code üíª, Sources üìö, Next steps ‚û°Ô∏è).
üîÅ Reminder: Missing emojis = incomplete response. Always use emojis üéâ naturally.
`
;

  activeId = userData.activeId || '';

  if (!conversations.length) {
    const id = 'c_' + Date.now();
    conversations = [{id, title:'New Conversation', createdAt:Date.now(), messages:[{role:'ai', text:'Hello! I\'m Shady, your AI assistant. How can I help you today?'}]}];
    activeId = id;
  }

  if (!activeId && conversations.length) {
    activeId = conversations[0].id;
  }

  renderChatList();
  setActiveConversation(activeId);
}

function saveUserData(userId) {
  const userData = {
    conversations: conversations,
    promptInjection: promptInjection,
    activeId: activeId
  };
  localStorage.setItem(`${USER_STORAGE_KEY}_${userId}`, JSON.stringify(userData));
}

// Chat management functions
function deleteChat(chatId) {
  if (conversations.length <= 1) {
    alert('You need to have at least one chat.');
    return;
  }

  if (confirm('Are you sure you want to delete this chat?')) {
    conversations = conversations.filter(c => c.id !== chatId);

    if (activeId === chatId) {
      activeId = conversations[0]?.id || '';
      if (activeId) {
        setActiveConversation(activeId);
      }
    }

    // Save user data if signed in
    const user = auth.currentUser;
    if (user) {
      saveUserData(user.uid);
    } else {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
    }
    renderChatList();
  }
}

function renameChat(chatId, newTitle) {
  const chat = conversations.find(c => c.id === chatId);
  if (chat) {
    chat.title = newTitle;

    // Save user data if signed in
    const user = auth.currentUser;
    if (user) {
      saveUserData(user.uid);
    } else {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
    }
    renderChatList();

    if (activeId === chatId) {
      convTitle.textContent = 'ShadowMind';
    }
  }
}

function showRenameModal(chatId) {
  const chat = conversations.find(c => c.id === chatId);
  if (chat) {
    chatToRename = chatId;
    renameChatInput.value = chat.title;
    renameChatModal.style.display = 'flex';
    renameChatInput.focus();
    renameChatInput.select();
  }
}

// Auto-name chat based on first user message
function updateChatTitle(convId, userMessage) {
  const conv = conversations.find(c => c.id === convId);
  if (!conv) return;

  if (conv.title.startsWith('New Conversation') || conv.title.startsWith('Conversation ')) {
    const words = userMessage.split(/\s+/).slice(0, 5);
    const newTitle = words.join(' ') + (words.length >= 5 ? '...' : '');
    conv.title = newTitle;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
    renderChatList();

    if (activeId === convId) {
      convTitle.textContent = newTitle;
    }
  }
}

// Render chat list
function renderChatList(){
  chatListEl.innerHTML = '';
  conversations.slice().reverse().forEach(conv => {
    const el = document.createElement('div');
    el.className = 'chat-item' + (conv.id === activeId ? ' active' : '');
    el.dataset.id = conv.id;
    el.innerHTML = `
      <div class="chat-item-title">${escapeHtml(conv.title)}</div>
      <div class="chat-item-actions">
        <button class="chat-actions-btn" onclick="showRenameModal('${conv.id}')" title="Rename chat">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
          </svg>
        </button>
        <button class="chat-actions-btn" onclick="deleteChat('${conv.id}')" title="Delete chat">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M3 6h18"/>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            <line x1="10" y1="11" x2="10" y2="17"/>
            <line x1="14" y1="11" x2="14" y2="17"/>
          </svg>
        </button>
      </div>
    `;
    el.addEventListener('click', (e) => {
      if (!e.target.closest('.chat-item-actions')) {
        setActiveConversation(conv.id);

        if (window.innerWidth <= 900) {
          sidebar.classList.remove('sidebar-open');
          sidebarOverlay.classList.remove('active');
        }
      }
    });
    chatListEl.appendChild(el);
  });
}

// Escape HTML
function escapeHtml(s=''){
  return String(s).replace(/[&<>"']/g, c =>
    ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])
  );
}

// Set active conversation
function setActiveConversation(id){
  activeId = id;
  localStorage.setItem(ACTIVE_KEY, id);
  const conv = conversations.find(c => c.id === id);
  if(!conv) return;
  convTitle.textContent = 'ShadowMind';
  renderMessages(conv.messages);
  renderChatList();
}

// Render messages
function renderMessages(messages){
  chatWindow.innerHTML = '';
  messages.forEach(m => appendMessage(m));
  scrollToBottom();
}

// Append message
function appendMessage(msg){
  const wrapper = document.createElement('div');
  wrapper.className = 'chat-message ' + (msg.role === 'user' ? 'user' : '');

  let content = formatMarkdown(msg.text || '');

  if (msg.meta && msg.meta.hasImage) {
    content = `<div style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">üì∑ Image attached</div>` + content;
  }

  if (msg.meta && msg.meta.generatedImage) {
    content += `<div style="margin-top: 12px">
      <img src="${msg.meta.generatedImage}" alt="Generated image" class="generated-image" onclick="openImageModal('${msg.meta.generatedImage}')" style="cursor: pointer;" />
      <button class="download-btn" onclick="downloadImage('${msg.meta.generatedImage}', '${msg.meta.imagePrompt || 'generated_image'}')">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7,10 12,15 17,10"/>
          <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        Download
      </button>
    </div>`;
  }

  const messageHTML = `
    <div class="message-content">${content}</div>
  `;

  wrapper.innerHTML = messageHTML;
  chatWindow.appendChild(wrapper);
}

// Markdown formatting
function formatMarkdown(text) {
  if (!text) return '';

  // Convert headings
  text = text.replace(/^### (.*$)/gm, '<h3>$1</h3>');
  text = text.replace(/^## (.*$)/gm, '<h2>$1</h2>');
  text = text.replace(/^# (.*$)/gm, '<h1>$1</h1>');

  // Convert tables
  text = text.replace(/(\|.*\|\n\|[\-\|:]+\|\n(?:\|.*\|\n)*)/g, function(match) {
    const lines = match.trim().split('\n');
    if (lines.length < 2) return match;
    const headers = lines[0].split('|').slice(1, -1).map(h => h.trim());
    const rows = lines.slice(2).map(line => line.split('|').slice(1, -1).map(cell => cell.trim()));
    let html = '<table><thead><tr>';
    headers.forEach(h => html += `<th>${h}</th>`);
    html += '</tr></thead><tbody>';
    rows.forEach(row => {
      html += '<tr>';
      row.forEach(cell => html += `<td>${cell}</td>`);
      html += '</tr>';
    });
    html += '</tbody></table>';
    return html;
  });

  // Convert **bold** to <strong>
  text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

  // Convert *italic* to <em>
  text = text.replace(/\*(.*?)\*/g, '<em>$1</em>');


  // Convert ```code blocks``` to <pre><code> with escaped HTML and copy button
  text = text.replace(/```(\w+)?\n([\s\S]*?)```/g, function(match, lang, code) {
    const escapedCode = escapeHtml(code);
    const langAttr = lang ? ` class="language-${lang}"` : '';
    const copyBtn = `<button class="copy-btn" onclick="copyToClipboard('${escapedCode.replace(/'/g, "\\'")}')">Copy</button>`;
    return `<div class="code-block-container"><pre><code${langAttr}>${escapedCode}</code></pre>${copyBtn}</div>`;
  });

  // Convert line breaks
  text = text.replace(/\n/g, '<br>');

  return text;
}

// Push message to conversation
function pushMessage(role, text, meta){
  const conv = conversations.find(c => c.id === activeId);
  if(!conv) return;
  conv.messages.push({role, text, time: Date.now(), meta});

  if (role === 'user' && conv.messages.filter(m => m.role === 'user').length === 1) {
    updateChatTitle(conv.id, text);
  }

  // Save user data if signed in
  const user = auth.currentUser;
  if (user) {
    saveUserData(user.uid);
  } else {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
  }
  setActiveConversation(activeId);
}

// Scroll to bottom
function scrollToBottom(){
  requestAnimationFrame(() => {
    chatWindow.scrollTop = chatWindow.scrollHeight;
  });
}

// Send text message
sendBtn.addEventListener('click', async () => {
  console.log('Send button clicked');
  const text = sanitizeInput(inputEl.value);
  if(!text) return;

  // Rate limiting check
  const userId = auth.currentUser ? auth.currentUser.uid : 'anonymous';
  if (!checkRateLimit(userId)) {
    alert('Too many requests. Please wait a moment before sending another message.');
    return;
  }

  // Check if user wants to search
  const searchRegex = /^search\s+/i;
  if (searchRegex.test(text)) {
    const query = text.replace(searchRegex, '').trim();
    if (query) {
      inputEl.value = '';
      performWebSearchAndRespond(query);
      return;
    }
  }

  if (currentImageDataUrl) {
    await sendImageWithPrompt(text);
    return;
  }

  if (imageGenerationEnabled) {
    inputEl.value = '';
    generateImage(text);
    return;
  }

  // Test case: if user types "hhhhsssshhhh", show a long message immediately
  if (text === "hhhhsssshhhh") {
    pushMessage('user', text);
    inputEl.value = '';
    inputEl.style.height = 'auto';
    const longMessage = "***This is a very long test message to verify that AI messages are displaying correctly without the typing animation. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. " +
      "Additional content: Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra. Vestibulum erat wisi, condimentum sed, commodo vitae, ornare sit amet, wisi. Aenean fermentum, elit eget tincidunt condimentum, eros ipsum*** rutrum orci, sagittis tempus lacus enim ac dui. Donec non enim in turpis pulvinar facilisis. Ut felis. Praesent dapibus, neque id cursus faucibus, tortor neque egestas augue, eu vulputate magna eros eu erat. Aliquam erat volutpat. Nam dui mi, tincidunt quis, accumsan porttitor, facilisis luctus, metus.";
    pushMessage('ai', longMessage);
    return;
  }

  pushMessage('user', text);
  inputEl.value = '';
  inputEl.style.height = 'auto';

  // Show typing indicator
  const typingIndicator = document.createElement('div');
  typingIndicator.className = 'chat-message';
  typingIndicator.innerHTML = `
    <div class="message-content">
      <div class="typing-indicator">
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
      </div>
    </div>
  `;
  chatWindow.appendChild(typingIndicator);
  scrollToBottom();

  try {
    const result = await callGroqChat(text);
    // Remove typing indicator
    chatWindow.removeChild(typingIndicator);
    // Push the AI message
    pushMessage('ai', result);
  } catch(err){
    chatWindow.removeChild(typingIndicator);
    pushMessage('ai', 'Error: ' + (err && err.message ? err.message : 'Request failed'));
  }
});

inputEl.addEventListener('keydown', e => {
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    sendBtn.click();
  }
});

// New conversation
btnNew.addEventListener('click', () => {
  const id = 'c_' + Date.now();
  const conv = {id, title:'New Conversation', createdAt:Date.now(), messages:[{role:'ai', text:'Hello! I\'m Shady, your AI assistant. How can I help you today?'}]};
  conversations.push(conv);

  // Save user data if signed in
  const user = auth.currentUser;
  if (user) {
    saveUserData(user.uid);
  } else {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
  }
  renderChatList();
  setActiveConversation(id);
});

// WEB SEARCH
async function performWebSearch(query) {
  try {
    const response = await fetch(`${API_BASE_URL}/api/search`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ query: query })
    });

    if (!response.ok) {
      throw new Error(`Search failed: ${response.status}`);
    }

    const data = await response.json();
    return data.results || [];
  } catch (err) {
    console.error('Search error:', err);
    return [];
  }
}

async function performWebSearchAndRespond(query) {
  pushMessage('user', `Search: ${query}`);
  pushMessage('ai', 'Searching the web...');

  try {
    const searchResults = await performWebSearch(query);

    if (searchResults.length === 0) {
      replaceLastAI('No search results found. Please try a different query.');
      return;
    }

    // Format search results for AI processing
    let searchContext = `Web search results for "${query}":\n\n`;
    searchResults.forEach((result, index) => {
      searchContext += `${index + 1}. **${result.title}**\n`;
      searchContext += `${result.content}\n`;
      if (result.url) {
        searchContext += `Source: ${result.url}\n`;
      }
      searchContext += '\n';
    });

    // Now ask the AI to process and respond based on the search results
    const aiPrompt = `Based on the following web search results, please provide a comprehensive and helpful answer to the user's query: "${query}"

${searchContext}

Please provide a clear, accurate answer based on these search results. If the results don't fully answer the query, acknowledge this and provide the best information available.`;

    const aiResponse = await callGroqChat(aiPrompt);
    replaceLastAI(aiResponse);

  } catch (err) {
    replaceLastAI('Search failed. Please try again later.');
  }
}

// IMAGE GENERATION
async function generateImage(prompt) {
  if (!prompt) return;

  pushMessage('user', `Generate image: ${prompt}`);
  pushMessage('ai', 'Generating image...');

  try {
    const imageUrl = await generateImageWithServer(prompt);

    if (imageUrl) {
      replaceLastAI(`Image generated successfully!`, {generatedImage: imageUrl, imagePrompt: prompt});

      imageGenerationEnabled = false;
      imageGenerationToggleSwitch.classList.remove('active');
      updateModeIndicator();
      inputEl.placeholder = "Message Shady...";
    } else {
      replaceLastAI('Image generation failed. Please try again.');
    }
  } catch (err) {
    replaceLastAI('Image generation failed: ' + (err.message || err));
  }
}

// Download generated image
function downloadImage(dataUrl, filename) {
  const link = document.createElement('a');
  link.href = dataUrl;
  link.download = `${filename}.png`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

// Open image in full screen modal
function openImageModal(imageSrc) {
  imageModalImg.src = imageSrc;
  imageModal.style.display = 'flex';
}

// Close image modal
imageModalClose.addEventListener('click', () => {
  imageModal.style.display = 'none';
});

// Close modal when clicking outside
imageModal.addEventListener('click', (e) => {
  if (e.target === imageModal) {
    imageModal.style.display = 'none';
  }
});

// IMAGE UPLOAD and VISION
imageInput.addEventListener('change', async (ev) => {
  const file = ev.target.files && ev.target.files[0];
  if(!file) return;

  // Security: Validate file before processing
  if (!validateFileUpload(file)) {
    imageInput.value = '';
    return;
  }

  const convId = activeId;
  const allowedAt = imageCooldowns[convId] || 0;
  if(Date.now() < allowedAt){
    alert('Image upload is on cooldown. Please wait a bit.');
    return;
  }

  const url = URL.createObjectURL(file);
  previewImg.src = url;
  previewImg.style.display = 'inline-block';

  try {
    const b64 = await fileToBase64(file);
    currentImageDataUrl = `data:${file.type};base64,${b64}`;

    inputEl.placeholder = "Ask a question about the image...";
    updateModeIndicator();
    inputEl.focus();
  } catch (err) {
    console.error('Error processing image:', err);
    alert('Error processing image. Please try another file.');
    imageInput.value = '';
  }
});

// Send image with user's prompt
async function sendImageWithPrompt(prompt) {
  if (!currentImageDataUrl) return;

  const convId = activeId;

  pushMessage('user', prompt, {hasImage: true});
  pushMessage('ai', 'Analyzing image...');

  try {
    const respText = await callGroqVision(prompt, currentImageDataUrl);
    imageCooldowns[convId] = Date.now() + IMAGE_COOLDOWN_MS;
    replaceLastAI(respText, {imageResult: respText});
  } catch (err) {
    replaceLastAI('Image analysis failed: ' + (err.message||err));
  } finally {
    previewImg.style.display = 'none';
    imageInput.value = '';
    currentImageDataUrl = null;
    inputEl.placeholder = "Message Shady...";
    updateModeIndicator();
    inputEl.value = '';
  }
}

// Convert File to base64
function fileToBase64(file){
  return new Promise((res, rej) => {
    const r = new FileReader();
    r.onload = () => {
      const dataUrl = r.result || '';
      const comma = dataUrl.indexOf(',');
      if(comma>=0) res(dataUrl.slice(comma+1));
      else res('');
    };
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}

// STT (record audio)
let mediaRecorder = null;
let recordedChunks = [];
let isRecording = false;

function startRecording(){
  if(isRecording){
    mediaRecorder.stop();
    return;
  }

  if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
    alert('Media capture not supported in this browser.');
    return;
  }

  try {
    navigator.mediaDevices.getUserMedia({audio:true}).then(stream => {
      recordedChunks = [];
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = async () => {
        isRecording = false;
        const audioBlob = new Blob(recordedChunks, {type:'audio/webm'});
        pushMessage('user', '[Voice message sent]');
        pushMessage('ai', 'Transcribing voice...');
        try {
          const transcript = await sendAudioToGroqTranscription(audioBlob);
          replaceLastAI(transcript);
          pushMessage('user', `[Transcription] ${transcript}`);
          pushMessage('ai', 'Thinking...');
          const reply = await callGroqChat(transcript, {model: TEXT_MODEL});
          replaceLastAI(reply);
          lastAITextForTTS = reply;
        } catch(err){
          replaceLastAI('Transcription failed: '+(err.message||err));
        }
        stream.getTracks().forEach(t=>t.stop());
      };
      mediaRecorder.start();
      isRecording = true;
    });
  } catch (err) {
    alert('Could not start audio capture: ' + err.message);
  }
}

// TTS playback
let lastAITextForTTS = '';
function playTTS(){
  const conv = conversations.find(c=>c.id===activeId);
  if(!conv) return;
  const lastAI = [...conv.messages].reverse().find(m=>m.role==='ai');
  if(!lastAI) return alert('No AI message to speak');
  const text = lastAI.text;
  try {
    playTTSBtn.disabled = true;
    fetchGroqTTS(text).then(audioUrl => {
      const audio = new Audio(audioUrl);
      audio.play();
      audio.onended = () => {
        URL.revokeObjectURL(audioUrl);
        playTTSBtn.disabled = false;
      };
    });
  } catch (err){
    alert('TTS failed: '+ (err.message||err));
    playTTSBtn.disabled = false;
  }
}

// ========= Server API Wrappers =========
async function callGroqChat(prompt, opts = {}) {
  try {
    // Build conversation history
    const conv = conversations.find(c => c.id === activeId);
    if (!conv) throw new Error('No active conversation');

    const messages = [
      { role: 'system', content: promptInjection }
    ];

    // Add all previous messages
    for (const msg of conv.messages) {
      if (msg.role === 'user' || msg.role === 'ai') {
        messages.push({
          role: msg.role === 'ai' ? 'assistant' : 'user',
          content: msg.text
        });
      }
    }

    // Add the current prompt
    messages.push({ role: 'user', content: prompt });

    const response = await fetch(`${API_BASE_URL}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: messages,
        model: opts.model || TEXT_MODEL,
        max_tokens: opts.max_tokens || 4000,
        temperature: opts.temperature || 0.2
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    const data = await response.json();
    return data.response;
  } catch (err) {
    throw new Error(err.message || 'Chat request failed');
  }
}

async function callGroqVision(prompt, imageDataUrl) {
  try {
    const response = await fetch(`${API_BASE_URL}/vision`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: prompt,
        system_prompt: promptInjection,
        image_data: imageDataUrl
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    const data = await response.json();
    return data.response;
  } catch (err) {
    throw new Error(err.message || 'Vision request failed');
  }
}

async function generateImageWithServer(prompt) {
  try {
    const response = await fetch(`${API_BASE_URL}/generate-image`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: prompt
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    const data = await response.json();
    return data.image_url;
  } catch (err) {
    throw new Error(err.message || 'Image generation failed');
  }
}

async function sendAudioToGroqTranscription(blob) {
  try {
    const formData = new FormData();
    formData.append('file', blob, 'recording.webm');

    const response = await fetch(`${API_BASE_URL}/transcribe`, {
      method: 'POST',
      body: formData
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    const data = await response.json();
    return data.transcription;
  } catch (err) {
    throw new Error(err.message || 'Transcription failed');
  }
}

async function fetchGroqTTS(text) {
  try {
    const response = await fetch(`${API_BASE_URL}/tts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        text: text,
        voice: 'en'
      })
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || `Server error: ${response.status}`);
    }

    const data = await response.json();

    const audioResponse = await fetch(data.audio);
    const audioBlob = await audioResponse.blob();
    return URL.createObjectURL(audioBlob);
  } catch (err) {
    throw new Error(err.message || 'TTS failed');
  }
}

// Replace last AI message
function replaceLastAI(text, meta){
  const conv = conversations.find(c=>c.id===activeId);
  if(!conv) return;
  for(let i=conv.messages.length-1;i>=0;i--){
    if(conv.messages[i].role==='ai'){
      conv.messages[i].text = text;
      if(meta) conv.messages[i].meta = meta;
      break;
    }
  }

  // Save user data if signed in
  const user = auth.currentUser;
  if (user) {
    saveUserData(user.uid);
  } else {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(conversations));
  }
  setActiveConversation(activeId);
}





// Initialize
setupAuth();
inputEl.focus();

// Show initial preview hidden until image selected
previewImg.style.display = 'none';

// Server health check
async function checkServerHealth() {
  try {
    const response = await fetch(`${API_BASE_URL}/health`);
    if (!response.ok) {
      console.warn('Server is not responding');
      pushMessage('', 'SERVER IS UPDATING OR CURRENTLY DOWN');
    }
  } catch (err) {
    console.warn('Server health check failed:', err);
    pushMessage('ai', 'SERVER IS UPDATING OR CURRENTLY DOWN');
  }
}

// Check server health on startup
checkServerHealth();

// Copy to clipboard function
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).then(() => {
    // Show temporary feedback
    const btn = event.target;
    const originalText = btn.textContent;
    btn.textContent = 'Copied!';
    btn.style.background = 'var(--accent-primary)';
    btn.style.color = 'var(--bg-primary)';
    setTimeout(() => {
      btn.textContent = originalText;
      btn.style.background = 'var(--bg-accent)';
      btn.style.color = 'var(--text-primary)';
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy: ', err);
    alert('Failed to copy to clipboard');
  });
}

// Cleanup on refresh
window.addEventListener('beforeunload', () => {
  try {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(ACTIVE_KEY);
  } catch(e){}
});
</script>
</body>
</html>
